# 智能外卖柜样机 - 业务逻辑文档

## 一、电平约定

### GPIO电平定义
- **geter（输入检测）GPIO**: 默认电平为1（未触发），0表示触发
- **seter（输出控制）GPIO**: 
  - 普通设备：1为开启，0为关闭
  - 嗡鸣器：低电平触发，需预设为1

---

## 二、系统状态机

### 状态定义

| 状态 | 说明 | 外卖员侧 | 学生侧 |
|------|------|----------|--------|
| BOOT | 启动初始化 | 不可用 | 不可用 |
| WAITING_INIT | 等待初始化按钮 | 不可用 | 不可用 |
| INITIALIZING | 初始化中 | 不可用 | 不可用 |
| CHECKING | 检查柜内物品 | 不可用 | 不可用 |
| CLEARING | 清理柜内物品 | 不可用 | 可用（开门） |
| IDLE | 空闲状态 | 可用 | 不可用 |
| OCCUPIED | 占用状态 | 不可用 | 可用（验证码） |
| PICKING | 取件中 | 不可用 | 可用（开门） |

### 状态转换图

```
BOOT → WAITING_INIT → INITIALIZING → CHECKING
                                           ↓
                                    有物品?
                                  ↙         ↘
                                 是           否
                                 ↓             ↓
                            CLEARING          IDLE
                                 ↓             ↓
                          (清理完成)      (外卖员按下)
                                 ↓             ↓
                                IDLE ←─────────┘
                                                 ↓
                                            (红外检测到物品)
                                                 ↓
                                              OCCUPIED
                                                 ↓
                                            (学生输入验证码)
                                                 ↓
                                              PICKING
                                                 ↓
                                            (关门后检测)
                                          ↙             ↘
                                         有物品         无物品
                                         ↓               ↓
                                       重新开门         IDLE
```

---

## 三、业务流程

### 1. 启动流程

**步骤**:
1. 系统启动，进入BOOT状态
2. 外卖员LCD显示"1"，学生LCD显示"2"
3. 进入WAITING_INIT状态，等待初始化

**初始化触发**:
- 检测到学生侧内部按钮（GPIO3）按下（电平变为0）
- 持续按住5秒后触发初始化流程

**初始化执行**:
1. 设置嗡鸣器电平为1，持续1秒（提示音）
2. 进入CHECKING状态，开始检测柜内物品

---

### 2. 柜内物品检测流程

**检测条件**: 任一红外传感器（GPIO1或GPIO2）电平变为0即判断为有物品

**情况A：柜内有物品**
1. 进入CLEARING状态
2. 打开学生侧柜门（GPIO5，脉冲1秒）
3. 等待工作人员清理物品后关门
4. 检测到门关闭后，再次检测柜内物品
   - **仍有人物**: 嗡鸣器闪烁5次（每次1秒），保持CLEARING状态，重新开门
   - **已清空**: 进入IDLE状态，关闭学生侧控制

**情况B：柜内无物品**
1. 直接进入IDLE状态
2. 此时外卖员侧按钮启用，学生侧禁用

---

### 3. 外卖员存物流程

**前置条件**: 系统处于IDLE状态

**步骤**:
1. 外卖员按下外部按钮（GPIO4，电平变为0）
2. 打开外卖员侧柜门（GPIO4，脉冲1秒）
3. 外卖员放入物品，关门
4. 红外传感器检测到物品（GPIO1或GPIO2变为0）
5. 进入OCCUPIED状态
6. **生成6位随机取件码**:
   - 使用加密安全的随机数生成器（`secrets`模块）
   - 检查验证码唯一性，确保不与历史验证码重复
   - 记录验证码生成时间和使用状态
   - 将验证码添加到历史记录（用于防重放攻击）
7. **打开外卖员侧LCD背光（GPIO1）**
8. 在外卖员LCD（SPI1）显示取件码
9. 外卖员将取件码发送给学生

---

### 4. 学生取物流程

**前置条件**: 系统处于OCCUPIED状态

**步骤**:
1. 学生在学生侧通过USB键盘开始输入验证码
2. **检测到首次输入时，打开学生侧LCD背光（GPIO2）**
3. **启动60秒输入超时定时器**
4. **每次有新输入时，重置超时定时器**
5. **实时显示当前输入**:
   - 验证码从右向左填充
   - 未输入的位置显示为空（不显示任何字符）
   - 例如输入"114514"的过程:
     - 输入"1" → 显示"     1"
     - 输入"11" → 显示"    11"
     - 输入"114" → 显示"   114"
     - 输入"1145" → 显示"  1145"
     - 输入"11451" → 显示" 11451"
     - 输入"114514" → 显示"114514"
6. 验证取件码是否正确
   - **验证流程**:
     1. 检查验证码长度是否为6位
     2. 检查验证码是否为纯数字
     3. 检查验证码是否存在于当前有效验证码列表
     4. 检查验证码是否在有效期内（3600秒）
     5. **防重放攻击检查**: 检查验证码是否在最近300秒内已被使用过
     6. 检查验证码是否已被使用过（如果配置为使用后立即失效）
   - **正确**: 
     - 标记验证码为已使用
     - 进入PICKING状态
     - 打开学生侧柜门（GPIO5，脉冲1秒）
     - **关闭学生侧LCD背光（GPIO2）**
   - **错误**: 
     - 根据错误类型在学生LCD（SPI2）显示对应错误码（Err001-Err005）
     - **重置超时定时器**
     - 等待重新输入
7. **输入超时处理（60秒无新输入）**:
   - 清空当前输入
   - 清除学生LCD显示内容，显示"Err007"
   - **关闭学生侧LCD背光（GPIO2）**
   - 等待重新输入
8. 学生取物后关门
9. 红外传感器检测柜内状态
   - **仍有物品**: 嗡鸣器闪烁5次，重新开门，保持PICKING状态
   - **已清空**: 
     - 进入IDLE状态
     - **关闭外卖员侧LCD背光（GPIO1）**
     - 外卖员侧按钮重新启用

---

## 四、关键时序约束

### 4.1 门锁控制

**约束**: 门锁通电时间**严格限制为1秒**，超过会烧坏门锁

**实现要求**:
- 门锁控制必须封装为独立方法
- 使用定时器或异步任务确保1秒后自动断电
- 严禁在门锁控制方法中执行其他耗时操作

**示例代码结构**:
```python
def open_door(door_gpio):
    """开门方法，确保门锁通电不超过1秒"""
    set_gpio(door_gpio, 1)  # 开门
    Timer(1.0, lambda: set_gpio(door_gpio, 0)).start()
```

---

### 4.2 红外传感器稳定

**约束**: 红外检测需要**2秒稳定时间**

**原因**: 箱体使用亚克力材料，强度不足，红外检测器会晃动导致电平跳变

**实现要求**:
- 检测到红外触发后，等待2秒再进行状态判断
- 在2秒稳定期内，忽略电平跳变
- 使用去抖动算法确保检测准确性

**示例代码结构**:
```python
def check_ir_sensor():
    """红外传感器检测，带2秒稳定时间"""
    if ir_triggered():
        time.sleep(2)  # 等待稳定
        if ir_triggered():  # 再次确认
            return True
    return False
```

---

## 五、异常处理

### 5.1 门锁故障

**检测**: 门锁命令发送后，门传感器（GPIO5或GPIO6）未在预期时间内变化

**处理**:
- 记录门锁故障日志
- 显示错误提示到LCD
- 进入安全模式，禁用对应门锁

---

### 5.2 红外传感器异常

**检测**: 红外传感器持续跳变，无法稳定

**处理**:
- 增加稳定时间至5秒
- 如仍无法稳定，标记传感器故障
- 使用备用传感器（如双传感器配置）

---

### 5.3 键盘输入超时

**检测**: 学生输入验证码超过60秒未完成

**处理**:
- 清空当前输入
- 清除学生LCD显示内容，显示"Err007"
- **关闭学生侧LCD背光（GPIO2）**
- 等待重新输入

### 5.4 键盘输入限制

**限制**: 只允许输入数字（0-9），不支持字母和特殊字符

**支持的按键**:
- **主键盘数字键**: 0-9（Linux key codes: 11, 2, 3, 4, 5, 6, 7, 8, 9, 10）
- **小键盘数字键**: 0-9（Linux key codes: 82, 79, 80, 81, 75, 76, 77, 71, 72, 73）
- **删除键**: 
  - 主键盘BACKSPACE（Linux key code: 14）
  - 小键盘减号KP_MINUS（Linux key code: 74）- **用于小键盘删除**
- **提交键**: ENTER（Linux key code: 28）

**按键映射**:
| 按键 | Linux Key Code | 功能 |
|------|----------------|------|
| 0-9（主键盘） | 11, 2, 3, 4, 5, 6, 7, 8, 9, 10 | 输入数字 |
| 0-9（小键盘） | 82, 79, 80, 81, 75, 76, 77, 71, 72, 73 | 输入数字 |
| BACKSPACE | 14 | 删除最后一个字符 |
| KP_MINUS | 74 | 删除最后一个字符（小键盘） |
| ENTER | 28 | 提交验证码 |

**注意**: 小键盘没有独立的删除键，使用小键盘减号（KP_MINUS）代替删除功能

---

### 5.4 验证码重复

**检测**: 生成的取件码与历史验证码重复

**处理**:
- 重新生成新的6位取件码
- 确保取件码唯一性
- 最多重试100次，超过则记录错误并报警

---

### 5.5 验证码过期

**检测**: 验证码生成时间超过有效期（3600秒）

**处理**:
- 标记验证码为已过期
- 从有效验证码列表中移除
- 在LCD显示错误提示"Err03"
- 等待外卖员重新存物

---

## 六、错误码表

| 错误码 | 说明 | 触发条件 | 处理方式 |
|--------|------|----------|----------|
| Err001 | 格式错误 | 输入非6位数字 | 清空输入，等待重新输入 |
| Err002 | 验证码不存在 | 输入的验证码未生成 | 清空输入，等待重新输入 |
| Err003 | 验证码已过期 | 验证码生成时间超过3600秒 | 清空输入，等待重新输入 |
| Err004 | 验证码已使用 | 验证码已被使用过 | 清空输入，等待重新输入 |
| Err005 | 验证码重复使用 | 验证码在300秒内已使用过（防重放） | 清空输入，等待重新输入 |
| Err007 | 输入超时 | 60秒无新输入 | 清空输入，关闭背光，等待重新输入 |
| Err008 | 门锁故障 | 门锁命令发送后门未打开 | 记录日志，禁用门锁，人工处理 |
| Err009 | 红外传感器异常 | 红外传感器持续跳变无法稳定 | 增加稳定时间，标记故障 |
| Err099 | 系统错误 | 未知错误 | 记录日志，重启系统 |

**错误码显示示例**:
- 学生输入"abc123" → 显示"Err001"（格式错误）
- 学生输入"000000"（未生成的验证码）→ 显示"Err002"（验证码不存在）
- 学生输入过期的验证码 → 显示"Err003"（验证码已过期）
- 学生输入已使用过的验证码 → 显示"Err004"（验证码已使用）
- 学生在300秒内重复使用验证码 → 显示"Err005"（验证码重复使用）
- 学生60秒无新输入 → 显示"Err007"（输入超时）

**注意**: 
- 错误码格式为"Err" + 三位数字（如"Err001"），总共6位，符合6位8段数码管显示要求
- 无验证码重试次数限制，学生可以无限次输入直到正确

---

## 七、验证码生成与安全机制

### 6.1 验证码生成算法

**随机数生成器选择**:
- **推荐**: `secrets` 模块（加密安全，适用于生产环境）
- **备选**: `random` 模块（非加密安全，仅适用于测试）

**生成流程**:
1. 使用加密安全的随机数生成器生成6位数字
2. 检查验证码是否与历史验证码重复
3. 如果重复，重新生成（最多重试100次）
4. 记录验证码生成时间戳
5. 将验证码添加到历史记录（保留最近1000个）
6. 标记验证码为"未使用"状态

**代码示例**:
```python
import secrets
from datetime import datetime

class PickupCodeGenerator:
    def __init__(self):
        self.code_history = []  # 历史验证码
        self.active_codes = {}  # 当前有效验证码 {code: {'created': timestamp, 'used': False}}
        self.history_size = 1000  # 历史记录保留数量

    def generate_code(self):
        """生成6位随机验证码"""
        max_retries = 100
        for _ in range(max_retries):
            # 使用加密安全的随机数生成器
            code = f"{secrets.randbelow(1000000):06d}"
            
            # 检查唯一性
            if code not in self.code_history and code not in self.active_codes:
                # 记录验证码
                timestamp = datetime.now().timestamp()
                self.active_codes[code] = {
                    'created': timestamp,
                    'used': False
                }
                self.code_history.append(code)
                
                # 限制历史记录大小
                if len(self.code_history) > self.history_size:
                    self.code_history.pop(0)
                
                return code
        
        raise RuntimeError("无法生成唯一验证码")
```

### 6.2 验证码验证机制

**验证流程**:
1. 检查验证码格式（6位纯数字）
2. 检查验证码是否存在
3. 检查验证码是否在有效期内（3600秒）
4. 检查验证码是否已被使用
5. **防重放攻击检查**: 检查验证码是否在最近300秒内已被使用过
6. 更新验证码状态

**代码示例**:
```python
class PickupCodeValidator:
    def __init__(self, generator):
        self.generator = generator
        self.replay_window = 300  # 防重放攻击时间窗口（秒）
        self.validity_period = 3600  # 验证码有效期（秒）

    def verify_code(self, code):
        """验证取件码"""
        current_time = datetime.now().timestamp()
        
        # 1. 检查格式
        if not code.isdigit() or len(code) != 6:
            return False, "Err001"
        
        # 2. 检查是否存在
        if code not in self.generator.active_codes:
            return False, "Err002"
        
        code_info = self.generator.active_codes[code]
        
        # 3. 检查有效期
        if current_time - code_info['created'] > self.validity_period:
            del self.generator.active_codes[code]
            return False, "Err003"
        
        # 4. 检查是否已使用
        if code_info['used']:
            return False, "Err004"
        
        # 5. 防重放攻击检查
        if self._check_replay_attack(code):
            return False, "Err005"
        
        # 验证成功，标记为已使用
        code_info['used'] = True
        
        return True, "验证成功"

    def _check_replay_attack(self, code):
        """检查防重放攻击"""
        current_time = datetime.now().timestamp()
        
        # 检查历史验证码中是否有相同验证码在时间窗口内被使用过
        for hist_code in self.generator.code_history:
            if hist_code == code:
                # 检查是否在时间窗口内
                if current_time - self.generator.active_codes.get(hist_code, {}).get('created', 0) < self.replay_window:
                    return True
        
        return False
```

### 6.3 防重放攻击机制

**原理**: 
- 记录每个验证码的使用时间和状态
- 在时间窗口（300秒）内，同一验证码不能重复使用
- 使用后立即失效（可配置）

**实现**:
- 维护验证码历史记录（最近1000个）
- 每次验证时检查历史记录
- 超过时间窗口的验证码自动清理

### 6.4 验证码唯一性保证

**方法**:
- 生成时检查历史验证码
- 最多重试100次生成唯一验证码
- 维护历史记录（最近1000个）

**概率分析**:
- 6位验证码共有1,000,000种可能
- 如果历史记录有1000个验证码，重复概率约为0.1%
- 100次重试后仍重复的概率约为10^-100（几乎不可能）

### 6.5 验证码有效期管理

**有效期**: 3600秒（1小时）

**清理机制**:
- 定期清理过期验证码（每60秒检查一次）
- 超过有效期的验证码自动从有效列表中移除

**代码示例**:
```python
def cleanup_expired_codes(self):
    """清理过期验证码"""
    current_time = datetime.now().timestamp()
    expired_codes = []
    
    for code, info in self.generator.active_codes.items():
        if current_time - info['created'] > self.validity_period:
            expired_codes.append(code)
    
    for code in expired_codes:
        del self.generator.active_codes[code]
    
    return len(expired_codes)
```

---

## 七、安全机制

### 7.1 紧急开门

**触发**: 学生侧内部按钮（GPIO3）长按5秒

**功能**: 强制打开学生侧柜门，用于紧急情况

**注意**: 此功能在所有状态下均可用

---

### 7.2 门锁保护

- 门锁通电时间严格限制为1秒
- 门锁命令发送后立即启动定时器断电
- 禁止连续发送门锁命令

### 7.3 验证码安全

- 使用加密安全的随机数生成器（`secrets`模块）
- 验证码唯一性保证（检查历史记录）
- 防重放攻击机制（300秒时间窗口）
- 验证码有效期管理（3600秒）
- 使用后立即失效（可配置）
- **无重试次数限制**，学生可以无限次输入直到正确

### 7.4 输入安全

- 键盘输入超时保护（60秒）
- 输入格式验证（6位纯数字）
- 输入长度限制（最多6位）
- 防止缓冲区溢出

---

## 八、显示规范

### 7.1 LCD显示内容

| 设备 | 状态 | 显示内容 | 背光状态 |
|------|------|----------|----------|
| 外卖员LCD (SPI1) | 启动 | "1" | 关闭 |
| 外卖员LCD (SPI1) | IDLE | "      " | 关闭 |
| 外卖员LCD (SPI1) | OCCUPIED | 6位取件码 | **开启** |
| 学生LCD (SPI2) | 启动 | "2" | 关闭 |
| 学生LCD (SPI2) | 等待输入 | "      " | 关闭 |
| 学生LCD (SPI2) | 输入验证码 | 当前输入（右对齐） | **开启** |
| 学生LCD (SPI2) | 格式错误 | "Err001" | **开启** |
| 学生LCD (SPI2) | 验证码不存在 | "Err002" | **开启** |
| 学生LCD (SPI2) | 验证码已过期 | "Err003" | **开启** |
| 学生LCD (SPI2) | 验证码已使用 | "Err004" | **开启** |
| 学生LCD (SPI2) | 验证码重复使用 | "Err005" | **开启** |
| 学生LCD (SPI2) | 输入超时 | "Err007" | **开启**（3秒后关闭） |
| 学生LCD (SPI2) | 门锁故障 | "Err008" | **开启** |
| 学生LCD (SPI2) | 红外传感器异常 | "Err009" | **开启** |
| 学生LCD (SPI2) | 系统错误 | "Err099" | **开启** |

**输入显示示例**（验证码"114514"）:
- 输入"1" → 显示"     1"
- 输入"11" → 显示"    11"
- 输入"114" → 显示"   114"
- 输入"1145" → 显示"  1145"
- 输入"11451" → 显示" 11451"
- 输入"114514" → 显示"114514"

**注意**: 
- LCD为6位8段数码管
- 错误提示使用"Err+三位错误码"的格式（如"Err001"），总共6位
- "Err"中的"E"和"r"可以在8段数码管上正确显示

### 7.2 LCD背光控制逻辑

#### 外卖员侧背光（GPIO1）
- **开启条件**: 系统进入OCCUPIED状态，显示取件码时
- **关闭条件**: 
  - 系统进入IDLE状态
  - 学生取物成功，系统返回IDLE状态

#### 学生侧背光（GPIO2）
- **开启条件**: 
  - 学生开始输入验证码（首次按键）
  - 显示错误提示时
  - 显示超时提示时
- **关闭条件**: 
  - 验证码正确，开门取物后
  - 输入超时（60秒无新输入），清除显示后
  - 错误提示显示3秒后，如无新输入

### 7.2 嗡鸣器提示

| 场景 | 模式 | 持续时间 |
|------|------|----------|
| 初始化完成 | 常响 | 1秒 |
| 物品未取完 | 闪烁 | 5次，每次1秒 |

**注意**: 嗡鸣器仅用于提醒学生物品未取完，不用于错误报警

---

## 九、实现建议

### 9.1 状态机实现

使用Python的状态机库或自定义状态机类，确保状态转换清晰可控。

```python
class CabinetStateMachine:
    STATES = ['BOOT', 'WAITING_INIT', 'INITIALIZING', 'CHECKING',
              'CLEARING', 'IDLE', 'OCCUPIED', 'PICKING']
    
    def transition(self, new_state):
        if self.can_transition(new_state):
            self.current_state = new_state
            self.on_state_enter(new_state)
```

### 9.2 异步任务

使用线程或协程处理门锁定时、红外稳定等需要延时的操作。

```python
import threading
import time

def delayed_door_lock(door_gpio):
    set_gpio(door_gpio, 1)
    time.sleep(1)
    set_gpio(door_gpio, 0)

def student_input_timeout_handler():
    """学生输入超时处理"""
    while True:
        time.sleep(1)
        if student_input_active:
            if time.time() - last_input_time > 60:
                # 超时处理
                clear_student_input()
                clear_student_lcd()
                set_gpio(student_lcd_backlight_gpio, 0)
                student_input_active = False
```

### 9.3 事件驱动

基于Unix Socket的事件驱动架构，确保响应及时。

```python
# 监听GPIO变化
# 监听键盘输入
# 根据事件触发状态转换

# 键盘输入事件处理
def on_key_event(event):
    if event['event_type'] == 'press':
        key = event['key']
        key_code = event['key_code']
        
        # 处理数字键（支持主键盘和小键盘）
        if key in '0123456789' or key_code in [82,79,80,81,75,76,77,71,72,73]:
            # 数字键输入（主键盘或小键盘）
            add_to_input_buffer(key)
            set_gpio(student_lcd_backlight_gpio, 1)  # 打开背光
            reset_input_timeout()  # 重置超时定时器
            # 实时显示当前输入（右对齐）
            display_input = current_input.rjust(6)  # 右对齐，空格填充
            send_to_lcd(student_lcd_device_id, display_input)
        
        # 处理删除键（支持BACKSPACE和KP_MINUS）
        elif key == 'BACKSPACE' or key == 'KP_MINUS':
            # 删除最后一个字符
            if len(current_input) > 0:
                current_input = current_input[:-1]
                reset_input_timeout()
                display_input = current_input.rjust(6)
                send_to_lcd(student_lcd_device_id, display_input)
        
        # 处理提交键
        elif key == 'ENTER':
            # 提交验证码
            verify_pickup_code()
```

---

## 十、测试场景

### 10.1 正常流程测试

1. 启动 → 初始化 → 空柜 → 存物 → 取物 → 空柜
2. 启动 → 初始化 → 有物品 → 清理 → 空柜 → 存物 → 取物 → 空柜

### 10.2 异常流程测试

1. 取物未清空 → 嗡鸣器提示 → 重新开门
2. 门锁故障 → 错误提示 → 禁用门锁
3. 验证码错误 → 显示错误 → 重新输入
4. 红外传感器跳变 → 2秒稳定 → 正确检测

### 10.3 边界测试

1. 门锁通电时间精确测试（0.9秒、1.0秒、1.1秒）
2. 红外稳定时间测试（1秒、2秒、3秒）
3. 验证码重复测试
4. 键盘输入超时测试
5. **LCD背光控制测试**:
   - 外卖员侧背光在有验证码时开启
   - 学生侧背光在输入时开启
   - 学生侧背光在60秒超时后关闭
   - 学生侧背光在验证成功后关闭
   - 外卖员侧背光在取物成功后关闭

---

### 10.4 安全测试

1. **验证码唯一性测试**: 连续生成1000个验证码，检查是否有重复
2. **防重放攻击测试**: 
   - 使用验证码后，在300秒内再次尝试使用
   - 验证应该失败，显示"Err05"
3. **验证码过期测试**: 
   - 等待3600秒后使用验证码
   - 验证应该失败，显示"Err03"
4. **重试次数测试**: 
   - 连续输入错误验证码多次
   - 验证应该允许无限次重试
5. **随机数质量测试**: 
   - 生成10000个验证码
   - 检查分布是否均匀
   - 使用卡方检验验证随机性
6. **错误码显示测试**: 
   - 触发各种错误，检查LCD是否正确显示对应的错误码
   - 确认"Err"格式在8段数码管上正确显示

---

## 十一、版本历史

| 版本 | 日期 | 修改内容 |
|------|------|----------|
| v1.0 | 2025-12-28 | 初始版本，定义完整业务逻辑和状态机 |
| v1.1 | 2025-12-28 | 添加LCD背光控制逻辑 |
| v1.2 | 2025-12-28 | 添加验证码生成与安全机制 |


